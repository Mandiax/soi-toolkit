#summary Concepts and definitions

= Concepts and definitions =

*Content*
<wiki:toc max_depth="3" />

= Introduction =

This page describes concepts and definitions used in the documentation of soi-toolkit.

The page is divided in the following sections:
 * *Definitions*
  * *Core Concepts*, describes some core concepts such as producer, consumer and messages.
  * *Exchange Patterns*, describes in what styles consumers and producers can exchange messages.
  * *Message Flows*, describes how exchange patterns can be combines into larger interaction when more than one producer and consumer is involved.
 * *Service Model*, describes a meta-model that can be used to describe a landscape of producers and consumers and how they exchange messages using services.

= Definitions =

== Core Concepts ==

|| *Icon* || *Term* || *Description ||
|| http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/SoftwareComponent.png || Software Component || A _software component_ is any type of software (e.g. system, web app, esb) that either consumes and/or produces services. A _software component_ is a coarse grained component, i.e. a system or web app and not a single program or class and typically consumer an/or produce more than one service. A _software component_ has its own CM-scope, i.e. its own release cycle. ||
|| http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/IntegrationComponent.png || Integration Component || A _software component_ build using soi-toolkit is called an _integration component_ and contains a number of related services and typically consumes a set of other services. ||
|| http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/Producer.png || Producer || A _software component_ that publish a service is called a _producer_ of that service. ||
|| http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/Consumer.png || Consumer ||  A _software component_ that uses a service is called a _consumer_ of that service. ||
|| http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/Message.png || Message || The actual _message_ (or payload) sent between the _consumer_ and _producer_ ||
|| http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/Sychronous%20Request:Response%20Messages.png || Synchronous Request/Response Invocation || The _consumer_ sends a request _message_ to the _producer_ and waits synchronously for a response _message_. ||
|| http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/Asychronous%20Message.png || Asynchronous One-Way Invocation || The _consumer_ sends a _message_ to the _producer_ and does not wait for the _producer_ to process the _message_. ||
|| http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/Asychronous%20Response%20Message.png || Asynchronous One-Way Response Invocation || The _producer_ sends back a response _message_ to the _consumer_ and does not wait for the _consumer_ to process the _message_. ||

== Exchange Patterns ==

_Exchange patterns_ describes different styles for how _consumers_ and _producers_ can exchange _messages_ in an abstract and logical way.

*Note*: The actual physical exchange taking place is transport dependent. E.g. a one-way exchange patterns describes that the consumer sends a message to the receiver but for polling transports (e.g. file based or database based trasports) it is actually the producer that polls the transport for new messages (e.g. files or database table rows).

soi-toolkit supports the following _exchange patterns_:

 * Request/Response
 * One-Way
 * Publish/Subscribe

=== Request/Response ===

When a consumer needs a response from the producer a _request/response_ exchange patterns can be used.
Mainly depending on how fast the consumer expects a response from the producer the pattern can be divided in a synchronous and an asynchronous variant.

The synchronous variant is in many cases simple to implement, e.g. using web services tools, but the asynchronous variant provides in general more robust solutions since it can guarente the delivery for the messages and for messaging based transports (e.g. JMS) the delivery can also be transactional. 

_NOTE_: An asynchronous request/response exchange pattern is actually built on two _one-way_ exchange patters, see below for more details.

If the expected response time is only a few seconds the synchronous variant can be used (due to its simplicity) but otherwise the asynchronous variant should be used if possible.

*Synchronous request/response exchange pattern*

http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/EP-RequestResponse-Synchronous.png

*Asynchronous request/response exchange pattern*

http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/EP-RequestResponse-Asynchronous.png

=== One-Way ===

If the consumer is not depending on a response from the producer a _one way_ exchange pattern is in most cases the preferred way.

The consumer sends the message asynchronously, i.e. does not wait for the producer to process the message and the underlying transport is expected to guarente the delivery of the message to the producer of the service.
Different transports fulfills the guarente of the delivery in various ways. In general messaging based transports (e.g. JMS) are preferred since they have the most robust implementation to guarente delivery of the messages and they can also be used by the consumer ans producer in a transactional way.

_NOTE_: The concepts consumer and producer are referring to consuming and producing *the service*, *not the message*. In a one-way exchange patter this might look confusing since it is the consumer that produce the message and the producer that consumes the message so it is very important to remember that the roles are related to the service and not the message!
 

http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/EP-OneWay.png

=== Publish/Subscribe ===

In the case where a number of software components are interested in information owned and maintained by another software components (the _master_ of the data) it is in many cases a good approach to apply a publish/subscribe exchange pattern.
The master publish changes to subscribers in a asynchronous fashion very similar to the one-way exchange pattern but instead of sending the message to exactly one service producer it is sent to zero, one or many service producers (i.e. the subscribers).

http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/EP-PublishSubscribe.png

== Message Flow ==

The exchange patterns described above can be combined into a _message flow_ to involve a number of software components to meet business demands, e.g. to fulfill a business process. 

http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/MessageFlow.png

= Service Model =

Once the use of services grows (i.e. the number of consumers and producers) in the system landscape it becomes more and more important to be able to describe the exiting and planned services, integrations and message flows in a structured and formal way.
Initially word documents, excel sheets and simple wiki pages will be sufficient but at some point will the number of consumers, producers and message flows make it very inconvenient to maintain the information when the system landscape changes.
Performing accurate "_what if analysis_" and answering questions like "_when can we shut down this old version of service xyz?_" will be very hard to answer...

Some kind of governance tool needs to be used. Either it is a commercial high-end tool or a simple database application a proper meta-model needs to be defined before services, consumers and producers can be described.

Soi-toolkit provides the following service model and it can be used by an organisation that use soi-toolkit, either _as is_ or as a starting point for a service model tailored for an organisations specific needs.

http://soi-toolkit.googlecode.com/svn/wiki/ConceptsAndDefinitions/ServiceModel.png
